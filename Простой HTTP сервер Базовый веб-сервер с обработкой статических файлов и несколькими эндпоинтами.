package main

import (
	"encoding/json"
	"fmt"
	"html/template"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"
)

type Server struct {
	port       string
	staticDir  string
	startTime  time.Time
	requests   int
}

type PageData struct {
	Title     string
	Message   string
	Time      string
	Requests  int
	Uptime    string
}

func NewServer(port, staticDir string) *Server {
	return &Server{
		port:      port,
		staticDir: staticDir,
		startTime: time.Now(),
		requests:  0,
	}
}

func main() {
	port := "8080"
	staticDir := "./static"

	if len(os.Args) > 1 {
		port = os.Args[1]
	}
	if len(os.Args) > 2 {
		staticDir = os.Args[2]
	}

	// –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö —Ñ–∞–π–ª–æ–≤, –µ—Å–ª–∏ –æ–Ω–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
	os.MkdirAll(staticDir, 0755)
	createSampleFiles(staticDir)

	server := NewServer(port, staticDir)
	server.setupRoutes()

	fmt.Println("üåê HTTP –°–µ—Ä–≤–µ—Ä")
	fmt.Printf("üöÄ –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞ –Ω–∞ –ø–æ—Ä—Ç—É %s\n", port)
	fmt.Printf("üìÅ –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ–∞–π–ª—ã –∏–∑: %s\n", staticDir)
	fmt.Printf("üåç –û—Ç–∫—Ä–æ–π—Ç–µ http://localhost:%s –≤ –±—Ä–∞—É–∑–µ—Ä–µ\n", port)
	fmt.Printf("%s\n", strings.Repeat("-", 50))

	log.Fatal(http.ListenAndServe(":"+port, nil))
}

func (s *Server) setupRoutes() {
	// Middleware –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞ –∑–∞–ø—Ä–æ—Å–æ–≤
	http.HandleFunc("/", s.withLogging(s.handleHome))
	http.HandleFunc("/api/status", s.withLogging(s.handleAPIStatus))
	http.HandleFunc("/api/time", s.withLogging(s.handleAPITime))
	http.HandleFunc("/api/echo", s.withLogging(s.handleAPIEcho))
	http.HandleFunc("/health", s.withLogging(s.handleHealth))
	
	// –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ–∞–π–ª—ã
	http.HandleFunc("/static/", s.withLogging(s.handleStatic))
}

func (s *Server) withLogging(handler http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		s.requests++
		start := time.Now()
		
		// –õ–æ–≥–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å
		fmt.Printf("üì® %s %s %s", r.Method, r.URL.Path, r.RemoteAddr)
		
		handler(w, r)
		
		// –õ–æ–≥–∏—Ä—É–µ–º –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
		duration := time.Since(start)
		fmt.Printf(" (%v)\n", duration)
	}
}

func (s *Server) handleHome(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/" {
		s.handleNotFound(w, r)
		return
	}

	tmpl := `<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{.Title}}</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; background: #f5f5f5; }
        .container { background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { color: #333; text-align: center; }
        .stats { background: #e8f4fd; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .api-list { background: #f8f9fa; padding: 15px; border-radius: 5px; }
        .endpoint { margin: 10px 0; }
        a { color: #007bff; text-decoration: none; }
        a:hover { text-decoration: underline; }
        .emoji { font-size: 1.2em; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåê {{.Title}}</h1>
        <p>{{.Message}}</p>
        
        <div class="stats">
            <h3>üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞</h3>
            <p>‚è∞ –í—Ä–µ–º—è —Å–µ—Ä–≤–µ—Ä–∞: {{.Time}}</p>
            <p>üìà –í—Å–µ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤: {{.Requests}}</p>
            <p>‚ö° –í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã: {{.Uptime}}</p>
        </div>

        <div class="api-list">
            <h3>üîó –î–æ—Å—Ç—É–ø–Ω—ã–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã</h3>
            <div class="endpoint">üìä <a href="/api/status">/api/status</a> - –°—Ç–∞—Ç—É—Å —Å–µ—Ä–≤–µ—Ä–∞ (JSON)</div>
            <div class="endpoint">‚è∞ <a href="/api/time">/api/time</a> - –¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è (JSON)</div>
            <div class="endpoint">üîÑ <a href="/api/echo?message=hello">/api/echo</a> - –≠—Ö–æ —Å–æ–æ–±—â–µ–Ω–∏—è (JSON)</div>
            <div class="endpoint">‚ù§Ô∏è <a href="/health">/health</a> - –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è</div>
            <div class="endpoint">üìÅ <a href="/static/">/static/</a> - –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ–∞–π–ª—ã</div>
        </div>
    </div>
</body>
</html>`

	t, err := template.New("home").Parse(tmpl)
	if err != nil {
		http.Error(w, "–û—à–∏–±–∫–∞ —à–∞–±–ª–æ–Ω–∞", http.StatusInternalServerError)
		return
	}

	data := PageData{
		Title:    "–ü—Ä–æ—Å—Ç–æ–π HTTP –°–µ—Ä–≤–µ—Ä",
		Message:  "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –°–µ—Ä–≤–µ—Ä —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ.",
		Time:     time.Now().Format("2006-01-02 15:04:05"),
		Requests: s.requests,
		Uptime:   time.Since(s.startTime).String(),
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	t.Execute(w, data)
}

func (s *Server) handleAPIStatus(w http.ResponseWriter, r *http.Request) {
	status := map[string]interface{}{
		"status":       "ok",
		"server":       "Simple HTTP Server",
		"version":      "1.0.0",
		"uptime":       time.Since(s.startTime).String(),
		"requests":     s.requests,
		"timestamp":    time.Now().Unix(),
		"time":         time.Now().Format("2006-01-02 15:04:05"),
	}

	s.writeJSON(w, status)
}

func (s *Server) handleAPITime(w http.ResponseWriter, r *http.Request) {
	timeData := map[string]interface{}{
		"unix":      time.Now().Unix(),
		"formatted": time.Now().Format("2006-01-02 15:04:05"),
		"iso":       time.Now().Format(time.RFC3339),
		"timezone":  time.Now().Format("MST"),
	}

	s.writeJSON(w, timeData)
}

func (s *Server) handleAPIEcho(w http.ResponseWriter, r *http.Request) {
	message := r.URL.Query().Get("message")
	if message == "" {
		message = "–ü—Ä–∏–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞!"
	}

	echo := map[string]interface{}{
		"echo":      message,
		"method":    r.Method,
		"path":      r.URL.Path,
		"timestamp": time.Now().Format("2006-01-02 15:04:05"),
		"client_ip": r.RemoteAddr,
	}

	s.writeJSON(w, echo)
}

func (s *Server) handleHealth(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/plain")
	w.WriteHeader(http.StatusOK)
	fmt.Fprintf(w, "‚úÖ Server is healthy\n‚è∞ Uptime: %s\nüìà Requests: %d\n", 
		time.Since(s.startTime).String(), s.requests)
}

func (s *Server) handleStatic(w http.ResponseWriter, r *http.Request) {
	// –£–±–∏—Ä–∞–µ–º /static/ –∏–∑ –ø—É—Ç–∏
	filepath := strings.TrimPrefix(r.URL.Path, "/static/")
	if filepath == "" {
		s.handleStaticIndex(w, r)
		return
	}

	fullPath := filepath.Join(s.staticDir, filepath)
	
	// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–∞–π–ª —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
	if _, err := os.Stat(fullPath); os.IsNotExist(err) {
		s.handleNotFound(w, r)
		return
	}

	http.ServeFile(w, r, fullPath)
}

func (s *Server) handleStaticIndex(w http.ResponseWriter, r *http.Request) {
	files, err := os.ReadDir(s.staticDir)
	if err != nil {
		http.Error(w, "–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	fmt.Fprintf(w, `<!DOCTYPE html>
<html>
<head>
    <title>üìÅ –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ–∞–π–ª—ã</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; }
        .file { margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px; }
        a { color: #007bff; text-decoration: none; }
        a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <h1>üìÅ –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ–∞–π–ª—ã</h1>
    <p><a href="/">‚Üê –ù–∞–∑–∞–¥ –Ω–∞ –≥–ª–∞–≤–Ω—É—é</a></p>
`)

	for _, file := range files {
		if !file.IsDir() {
			fmt.Fprintf(w, `<div class="file">üìÑ <a href="/static/%s">%s</a></div>`, 
				file.Name(), file.Name())
		}
	}

	fmt.Fprintf(w, `</body></html>`)
}

func (s *Server) handleNotFound(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	w.WriteHeader(http.StatusNotFound)
	fmt.Fprintf(w, `<!DOCTYPE html>
<html>
<head>
    <title>404 - –°—Ç—Ä–∞–Ω–∏—Ü–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
        .error { color: #dc3545; }
    </style>
</head>
<body>
    <h1 class="error">404 - –°—Ç—Ä–∞–Ω–∏—Ü–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞</h1>
    <p>–ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º—ã–π —Ä–µ—Å—É—Ä—Å –Ω–µ –Ω–∞–π–¥–µ–Ω: %s</p>
    <p><a href="/">‚Üê –í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞ –≥–ª–∞–≤–Ω—É—é</a></p>
</body>
</html>`, r.URL.Path)
}

func (s *Server) writeJSON(w http.ResponseWriter, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	json.NewEncoder(w).Encode(data)
}

func createSampleFiles(staticDir string) {
	// –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–º–µ—Ä HTML —Ñ–∞–π–ª–∞
	htmlContent := `<!DOCTYPE html>
<html>
<head>
    <title>–ü—Ä–∏–º–µ—Ä HTML —Ñ–∞–π–ª–∞</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .highlight { background: yellow; }
    </style>
</head>
<body>
    <h1>üéâ –≠—Ç–æ –ø—Ä–∏–º–µ—Ä HTML —Ñ–∞–π–ª–∞</h1>
    <p>–≠—Ç–æ—Ç —Ñ–∞–π–ª –æ–±—Å–ª—É–∂–∏–≤–∞–µ—Ç—Å—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏ —á–µ—Ä–µ–∑ HTTP —Å–µ—Ä–≤–µ—Ä.</p>
    <p class="highlight">–í—Ä–µ–º—è —Å–æ–∑–¥–∞–Ω–∏—è: ` + time.Now().Format("2006-01-02 15:04:05") + `</p>
</body>
</html>`

	os.WriteFile(filepath.Join(staticDir, "example.html"), []byte(htmlContent), 0644)

	// –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–º–µ—Ä CSS —Ñ–∞–π–ª–∞
	cssContent := `body {
    background-color: #f0f8ff;
    margin: 0;
    padding: 20px;
}

.container {
    max-width: 800px;
    margin: 0 auto;
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}`

	os.WriteFile(filepath.Join(staticDir, "style.css"), []byte(cssContent), 0644)

	// –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–º–µ—Ä —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞
	txtContent := "–≠—Ç–æ –ø—Ä–∏–º–µ—Ä —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞.\n–û–Ω –æ–±—Å–ª—É–∂–∏–≤–∞–µ—Ç—Å—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏ —á–µ—Ä–µ–∑ HTTP —Å–µ—Ä–≤–µ—Ä.\n–í—Ä–µ–º—è —Å–æ–∑–¥–∞–Ω–∏—è: " + time.Now().Format("2006-01-02 15:04:05")
	
	os.WriteFile(filepath.Join(staticDir, "readme.txt"), []byte(txtContent), 0644)
}
