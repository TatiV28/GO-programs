package main

import (
	"crypto/rand"
	"encoding/json"
	"fmt"
	"html/template"
	"log"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"
)

type URLEntry struct {
	ID          string    `json:"id"`
	OriginalURL string    `json:"original_url"`
	ShortCode   string    `json:"short_code"`
	CreatedAt   time.Time `json:"created_at"`
	Clicks      int       `json:"clicks"`
	LastAccess  *time.Time `json:"last_access,omitempty"`
}

type URLShortener struct {
	storage  map[string]*URLEntry
	baseURL  string
	filename string
}

type APIResponse struct {
	Success   bool        `json:"success"`
	Data      interface{} `json:"data,omitempty"`
	Error     string      `json:"error,omitempty"`
}

func NewURLShortener(baseURL, filename string) *URLShortener {
	us := &URLShortener{
		storage:  make(map[string]*URLEntry),
		baseURL:  baseURL,
		filename: filename,
	}
	us.loadFromFile()
	return us
}

func main() {
	port := "8080"
	baseURL := "http://localhost:8080"
	
	if len(os.Args) > 1 {
		port = os.Args[1]
	}
	if len(os.Args) > 2 {
		baseURL = os.Args[2]
	}

	shortener := NewURLShortener(baseURL, "urls.json")
	
	fmt.Println("üîó URL Shortener")
	fmt.Printf("üöÄ –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞ –Ω–∞ –ø–æ—Ä—Ç—É %s\n", port)
	fmt.Printf("üåç –ë–∞–∑–æ–≤—ã–π URL: %s\n", baseURL)
	fmt.Printf("üíæ –§–∞–π–ª —Ö—Ä–∞–Ω–µ–Ω–∏—è: urls.json\n")
	fmt.Printf("%s\n", strings.Repeat("-", 50))

	http.HandleFunc("/", shortener.handleHome)
	http.HandleFunc("/api/shorten", shortener.handleAPIShorten)
	http.HandleFunc("/api/stats/", shortener.handleAPIStats)
	http.HandleFunc("/api/list", shortener.handleAPIList)
	http.HandleFunc("/s/", shortener.handleRedirect)
	http.HandleFunc("/stats/", shortener.handleStats)

	log.Fatal(http.ListenAndServe(":"+port, nil))
}

func (us *URLShortener) handleHome(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/" {
		http.NotFound(w, r)
		return
	}

	tmpl := `<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîó URL Shortener</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; background: #f5f5f5; }
        .container { background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { text-align: center; color: #333; }
        .form-group { margin: 20px 0; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="url"] { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 5px; font-size: 16px; }
        button { background: #007bff; color: white; padding: 12px 24px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; }
        button:hover { background: #0056b3; }
        .result { margin: 20px 0; padding: 15px; background: #d4edda; border-radius: 5px; display: none; }
        .error { background: #f8d7da; color: #721c24; }
        .stats { background: #e8f4fd; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .url-list { margin: 20px 0; }
        .url-item { padding: 10px; border: 1px solid #eee; margin: 5px 0; border-radius: 5px; }
        .short-url { font-weight: bold; color: #007bff; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîó URL Shortener</h1>
        
        <form id="shortenForm">
            <div class="form-group">
                <label for="url">üåê –í–≤–µ–¥–∏—Ç–µ URL –¥–ª—è —Å–æ–∫—Ä–∞—â–µ–Ω–∏—è:</label>
                <input type="url" id="url" name="url" placeholder="https://example.com" required>
            </div>
            <button type="submit">‚úÇÔ∏è –°–æ–∫—Ä–∞—Ç–∏—Ç—å URL</button>
        </form>

        <div id="result" class="result"></div>

        <div class="stats">
            <h3>üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</h3>
            <p>üìà –í—Å–µ–≥–æ —Å—Å—ã–ª–æ–∫: <span id="totalUrls">{{.TotalUrls}}</span></p>
            <p>üëÜ –í—Å–µ–≥–æ –∫–ª–∏–∫–æ–≤: <span id="totalClicks">{{.TotalClicks}}</span></p>
        </div>

        <div class="stats">
            <h3>üîó API Endpoints</h3>
            <p>üìù POST /api/shorten - –°–æ–∫—Ä–∞—Ç–∏—Ç—å URL</p>
            <p>üìä GET /api/stats/{code} - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –∫–æ–¥—É</p>
            <p>üìã GET /api/list - –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö URL</p>
            <p>üîÑ GET /s/{code} - –†–µ–¥–∏—Ä–µ–∫—Ç –Ω–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π URL</p>
        </div>
    </div>

    <script>
        document.getElementById('shortenForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const url = document.getElementById('url').value;
            const resultDiv = document.getElementById('result');
            
            try {
                const response = await fetch('/api/shorten', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ url: url })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    resultDiv.className = 'result';
                    resultDiv.innerHTML = ` + "`" + `
                        <h3>‚úÖ URL —É—Å–ø–µ—à–Ω–æ —Å–æ–∫—Ä–∞—â–µ–Ω!</h3>
                        <p><strong>–û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π URL:</strong> ${data.data.original_url}</p>
                        <p><strong>–ö–æ—Ä–æ—Ç–∫–∏–π URL:</strong> <a href="${data.data.short_url}" class="short-url">${data.data.short_url}</a></p>
                        <p><strong>–ö–æ–¥:</strong> ${data.data.short_code}</p>
                        <p><strong>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</strong> <a href="/stats/${data.data.short_code}">–ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å</a></p>
                    ` + "`" + `;
                } else {
                    resultDiv.className = 'result error';
                    resultDiv.innerHTML = ` + "`" + `<h3>‚ùå –û—à–∏–±–∫–∞</h3><p>${data.error}</p>` + "`" + `;
                }
                
                resultDiv.style.display = 'block';
                
            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.innerHTML = ` + "`" + `<h3>‚ùå –û—à–∏–±–∫–∞</h3><p>–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∫—Ä–∞—â–µ–Ω–∏–∏ URL</p>` + "`" + `;
                resultDiv.style.display = 'block';
            }
        });
    </script>
</body>
</html>`

	t, _ := template.New("home").Parse(tmpl)
	
	stats := us.getGlobalStats()
	data := struct {
		TotalUrls   int
		TotalClicks int
	}{
		TotalUrls:   len(us.storage),
		TotalClicks: stats["total_clicks"].(int),
	}
	
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	t.Execute(w, data)
}

func (us *URLShortener) handleAPIShorten(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		us.writeError(w, "–ú–µ—Ç–æ–¥ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è", http.StatusMethodNotAllowed)
		return
	}

	var request struct {
		URL string `json:"url"`
	}

	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		us.writeError(w, "–ù–µ–≤–µ—Ä–Ω—ã–π JSON", http.StatusBadRequest)
		return
	}

	// –í–∞–ª–∏–¥–∞—Ü–∏—è URL
	if request.URL == "" {
		us.writeError(w, "URL –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º", http.StatusBadRequest)
		return
	}

	parsedURL, err := url.Parse(request.URL)
	if err != nil || (parsedURL.Scheme != "http" && parsedURL.Scheme != "https") {
		us.writeError(w, "–ù–µ–≤–µ—Ä–Ω—ã–π URL. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ http:// –∏–ª–∏ https://", http.StatusBadRequest)
		return
	}

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ —Ç–∞–∫–æ–π URL
	for _, entry := range us.storage {
		if entry.OriginalURL == request.URL {
			response := map[string]interface{}{
				"original_url": entry.OriginalURL,
				"short_url":    fmt.Sprintf("%s/s/%s", us.baseURL, entry.ShortCode),
				"short_code":   entry.ShortCode,
				"created_at":   entry.CreatedAt,
				"clicks":       entry.Clicks,
			}
			us.writeSuccess(w, response)
			return
		}
	}

	// –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å
	shortCode := us.generateShortCode()
	entry := &URLEntry{
		ID:          us.generateID(),
		OriginalURL: request.URL,
		ShortCode:   shortCode,
		CreatedAt:   time.Now(),
		Clicks:      0,
	}

	us.storage[shortCode] = entry
	us.saveToFile()

	response := map[string]interface{}{
		"original_url": entry.OriginalURL,
		"short_url":    fmt.Sprintf("%s/s/%s", us.baseURL, entry.ShortCode),
		"short_code":   entry.ShortCode,
		"created_at":   entry.CreatedAt,
		"clicks":       entry.Clicks,
	}

	fmt.Printf("‚úÖ –°–æ–∑–¥–∞–Ω –∫–æ—Ä–æ—Ç–∫–∏–π URL: %s -> %s/s/%s\n", request.URL, us.baseURL, shortCode)
	us.writeSuccess(w, response)
}

func (us *URLShortener) handleRedirect(w http.ResponseWriter, r *http.Request) {
	shortCode := strings.TrimPrefix(r.URL.Path, "/s/")
	
	entry, exists := us.storage[shortCode]
	if !exists {
		http.NotFound(w, r)
		return
	}

	// –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
	entry.Clicks++
	now := time.Now()
	entry.LastAccess = &now
	us.saveToFile()

	fmt.Printf("üîÑ –†–µ–¥–∏—Ä–µ–∫—Ç: %s -> %s (–∫–ª–∏–∫ #%d)\n", shortCode, entry.OriginalURL, entry.Clicks)
	http.Redirect(w, r, entry.OriginalURL, http.StatusFound)
}

func (us *URLShortener) handleAPIStats(w http.ResponseWriter, r *http.Request) {
	shortCode := strings.TrimPrefix(r.URL.Path, "/api/stats/")
	
	entry, exists := us.storage[shortCode]
	if !exists {
		us.writeError(w, "–ö–æ—Ä–æ—Ç–∫–∏–π URL –Ω–µ –Ω–∞–π–¥–µ–Ω", http.StatusNotFound)
		return
	}

	stats := map[string]interface{}{
		"short_code":   entry.ShortCode,
		"original_url": entry.OriginalURL,
		"created_at":   entry.CreatedAt,
		"clicks":       entry.Clicks,
		"last_access":  entry.LastAccess,
		"short_url":    fmt.Sprintf("%s/s/%s", us.baseURL, entry.ShortCode),
	}

	us.writeSuccess(w, stats)
}

func (us *URLShortener) handleAPIList(w http.ResponseWriter, r *http.Request) {
	var urls []map[string]interface{}
	
	for _, entry := range us.storage {
		urlData := map[string]interface{}{
			"short_code":   entry.ShortCode,
			"original_url": entry.OriginalURL,
			"short_url":    fmt.Sprintf("%s/s/%s", us.baseURL, entry.ShortCode),
			"created_at":   entry.CreatedAt,
			"clicks":       entry.Clicks,
			"last_access":  entry.LastAccess,
		}
		urls = append(urls, urlData)
	}

	us.writeSuccess(w, urls)
}

func (us *URLShortener) handleStats(w http.ResponseWriter, r *http.Request) {
	shortCode := strings.TrimPrefix(r.URL.Path, "/stats/")
	
	entry, exists := us.storage[shortCode]
	if !exists {
		http.NotFound(w, r)
		return
	}

	tmpl := `<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ - {{.ShortCode}}</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; }
        .container { background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .stat { margin: 15px 0; padding: 10px; background: #f8f9fa; border-radius: 5px; }
        .url { word-break: break-all; }
        a { color: #007bff; text-decoration: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫–æ—Ä–æ—Ç–∫–æ–≥–æ URL</h1>
        
        <div class="stat">
            <strong>üîó –ö–æ—Ä–æ—Ç–∫–∏–π –∫–æ–¥:</strong> {{.ShortCode}}
        </div>
        
        <div class="stat">
            <strong>üåê –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π URL:</strong><br>
            <div class="url"><a href="{{.OriginalURL}}" target="_blank">{{.OriginalURL}}</a></div>
        </div>
        
        <div class="stat">
            <strong>üìé –ö–æ—Ä–æ—Ç–∫–∏–π URL:</strong><br>
            <div class="url"><a href="{{.ShortURL}}">{{.ShortURL}}</a></div>
        </div>
        
        <div class="stat">
            <strong>üìÖ –°–æ–∑–¥–∞–Ω:</strong> {{.CreatedAt}}
        </div>
        
        <div class="stat">
            <strong>üëÜ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∏–∫–æ–≤:</strong> {{.Clicks}}
        </div>
        
        {{if .LastAccess}}
        <div class="stat">
            <strong>‚è∞ –ü–æ—Å–ª–µ–¥–Ω–∏–π –¥–æ—Å—Ç—É–ø:</strong> {{.LastAccess}}
        </div>
        {{end}}
        
        <p><a href="/">‚Üê –í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞ –≥–ª–∞–≤–Ω—É—é</a></p>
    </div>
</body>
</html>`

	t, _ := template.New("stats").Parse(tmpl)
	
	data := struct {
		ShortCode   string
		OriginalURL string
		ShortURL    string
		CreatedAt   string
		Clicks      int
		LastAccess  string
	}{
		ShortCode:   entry.ShortCode,
		OriginalURL: entry.OriginalURL,
		ShortURL:    fmt.Sprintf("%s/s/%s", us.baseURL, entry.ShortCode),
		CreatedAt:   entry.CreatedAt.Format("2006-01-02 15:04:05"),
		Clicks:      entry.Clicks,
	}
	
	if entry.LastAccess != nil {
		data.LastAccess = entry.LastAccess.Format("2006-01-02 15:04:05")
	}
	
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	t.Execute(w, data)
}

func (us *URLShortener) generateShortCode() string {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	const length = 6
	
	for {
		b := make([]byte, length)
		for i := range b {
			n, _ := rand.Int(rand.Reader, big.NewInt(int64(len(charset))))
			b[i] = charset[n.Int64()]
		}
		
		code := string(b)
		if _, exists := us.storage[code]; !exists {
			return code
		}
	}
}

func (us *URLShortener) generateID() string {
	b := make([]byte, 16)
	rand.Read(b)
	return fmt.Sprintf("%x", b)
}

func (us *URLShortener) getGlobalStats() map[string]interface{} {
	totalClicks := 0
	for _, entry := range us.storage {
		totalClicks += entry.Clicks
	}
	
	return map[string]interface{}{
		"total_urls":   len(us.storage),
		"total_clicks": totalClicks,
	}
}

func (us *URLShortener) writeSuccess(w http.ResponseWriter, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	json.NewEncoder(w).Encode(APIResponse{
		Success: true,
		Data:    data,
	})
}

func (us *URLShortener) writeError(w http.ResponseWriter, message string, statusCode int) {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(APIResponse{
		Success: false,
		Error:   message,
	})
}

func (us *URLShortener) saveToFile() {
	data, err := json.MarshalIndent(us.storage, "", "  ")
	if err != nil {
		fmt.Printf("‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: %v\n", err)
		return
	}
	
	os.WriteFile(us.filename, data, 0644)
}

func (us *URLShortener) loadFromFile() {
	data, err := os.ReadFile(us.filename)
	if err != nil {
		return // –§–∞–π–ª –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç - —ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ
	}
	
	err = json.Unmarshal(data, &us.storage)
	if err != nil {
		fmt.Printf("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: %v\n", err)
	}
}
